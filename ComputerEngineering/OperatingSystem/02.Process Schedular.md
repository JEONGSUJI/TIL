# Process Scheduler



## 인터럽트

### 인터럽트란?

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술이다. 인터럽트는 일종의 이벤트라고 불린다. 



### 인터럽트 필요 이유

- 선점형 스케쥴러 구현
  - 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스의 실행을 중단시킴 / 그러려면, 스케쥴러 코드가 실행이되서, 현 프로세스 실행을 중지해야 한다.
  - 예) 수시로 타이머 인터럽트 발생: 운영체제가 타이머 인터럽트 발생 횟수를 기억해서 5번 타이머 인터럽트 발생 시 현재 프로세스를 다른 프로세스로 바꿔준다.

- I/O Device와의 커뮤니케이션
  - 저장매체에서 데이터 처리 완료 시, 프로세스를 깨워야 한다. (block state -> ready state)

- 예외 상황 핸들링
  - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생한 경우 CPU가 처리할 수 있도록 CPU에게 알려줘야 한다.
  - 예시) 입출력 하드웨어 등의 장치 이슈: 파일 처리 종료를 운영체제에 알리기 -> 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
  - 예시) 예외 상황 발생 이슈: 0으로 나누는 계산과 같은 무한 루프 연산이 발생해서 예외 발생을 운영체제에 알리기 -> 운영체제가 해당 프로세스 실행 중지/에러 표시



### 주요 인터럽트

- 계산하는 코드에서 0으로 나누는 코드 (Divide-by-Zero Interrupt)

- 타이머 인터럽트
  - 선점형 스케쥴러를 위해 필요하다.
  - 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다.
- 입출력(IO) 인터럽트
  - 프린터, 키보드, 마우스, 저장 매체



### 인터럽트 종류

- **내부 인터럽트(=소프트웨어 인터럽트, 예외상황 인터럽트)**

  - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용 시 발생
  - 0으로 나눴을 때, 사용자 모드에서 허용되지 않은 명령 또는 공간 접근 시, 계산 결과 Overflow/Underflow

- **외부 인터럽트(=하드웨어 인터럽트)**

  - 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
  - 전원 이상, 기계문제, 키보드와 같은 IO 관련 이벤트, Timer 이벤트 등

- **시스템 콜 인터럽트**

  - 시스템 콜 실행을 위해 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.
  - 시스템 콜 실제코드

  ```
  mov eax, 1 	// 시스템 콜 번호
  mov ebx, 0	// 시스템 콜에 해당하는 인자값
  int 0x80	// 소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌
  ```

  - 시스템 콜 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌
    - CPU는 사용자 모드를 커널 모드로 바꿔줌
    - IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행함
    - system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
    - 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드를 진행 



### 인터럽트와 IDT

- 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 IDT(Interrupt Descriptor Table)에 기록되어 있다.
- 컴퓨터 부팅 시 운영체제가 기록하며, 운영체제 내부 코드가 기록된다.

- IDT에는 0x80 -> system_call()과 같은 정보가 기록되어 있다.

- 리눅스 예) 0~31: 예외상황 인터럽트, 32~47: 하드웨어 인터럽트, 128: 시스템 콜



### 인터럽트와 프로세스

- 프로세스 실행 중 인터럽트 발생
- 현 프로세스 실행 중단
- 인터럽트 처리 함수 실행(운영체제)
- 현 프로세스 재 실행





## 프로세스와 컨텍스트 스위칭

컨텍스트 스위칭이란 프로그램 A에서 프로그램 B로 갈 때, scedular에 의해 바뀔 때 B로 가게 만들어주는 것을 말한다.



### 프로세스의 구성

4가지의 영역(STACK, HEAP, DATA, TEXT)으로 나뉘어져있다.

- STACK: 임시 데이터(함수 호출, 로컬 변수) / 함수 내에서 실행되는 순으로 저장되었다가 실행 된 후 하나하나 지움
- HEAP : 코드에서 동적으로 만들어지는 데이터 / c에서는 동적으로 메모리를 할당할 때 malloc 함수를 사용한다.
- data: 코드를 컴파일 하는 순간 변수/초기화된 데이터 공간 확보
  - BSS : 초기화 되지 않은 전역변수
  - DATA : 초기값이 있는 전역변수
- text(Code): 컴파일된 소스코드가 저장된다.
- PCB 정보 (PC(Program Counter) + SP(Stack Pointer) )
  - PC, SP는 **PCB(Process Control Block, Process Context Block, 프로세스가 실행중인 상태를 캡쳐/구조화해서 저장)**에 저장한다.
  - PC는 중요한 레지스터, 실행할 코드의 주소가 들어있다.
  - SP는 STACK에 가장 윗 부분을 나타낸다. 함수가 실행되면 ETURN ADDRESS가 STACK에 쌓인다.
  - Process ID
  - Register (PC, SP 등)
  - Scheduling Info (Porcess State)
  - Memory Info (메모리 사이즈 limit)



> ebp: 함수에 문제가 있을 때 어떤 부분이 문제인지 빠르게 트래킹하기 위해 최상단 레지스터를 기록한다.

> 리눅스는 Process 부분이 4GB로 되어있다.



### 컨텍스트 스위칭(문맥 교환)

CPU에 실행할 프로세스를 교체하는 기술

PC, SP만 바꿔주면 프로세스 저장상태를 기반으로 실행 가능

굉장히 짧은 시간(ms)단위로, 프로세스 스튀칭이 일어난다.



#### 컨텍스트 스위칭 세부 동작

```
프로세스1 > ① 컨텍스트 스위칭 ② > 프로세스2
```

① 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장한다. 

② 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 CPU의 레지스터에 넣고, 실행



#### 컴파일러

초기 컴퓨터 프로그램들은 어셈블리어로 작성

	- 서로 다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램 작성
	- 어셈블리어로는 프로그램 작성 속도가 매우 떨어짐

컴파일러 등장

	- CPU 아키텍처에 따라서는 컴파일러 프로그램만 만들면 됨, 기존 코드는 재작성할 필요 없음(이식성이 높음)
	- 그러나, 어셈블리어로 작성한 코드보다는 속도가 떨어질 수 있음





## 프로세스간 커뮤니케이션

- InterProcess Communication(IPC), 프로세스간 통신 방법을 제공함
  - 그 중의 한가지 방법 : file 사용 (간단히 다른 프로세스에 전달할 내용을 파일에 쓰고, 다른 프로세스가 해당 파일을 읽으면 됨) 하지만 file을 사용하면, 실시간으로 직접 원하는 프로세스에 데이터 전달이 어렵다.
  - 다양한 IPC 기법: file 사용, Message Queue, Shared Memory, Pipe, Signal, Semaphore, Socker 등
    - file 빼고는 **커널 공간을 사용**한다. 커널 공간은 물리 메모리에 있어 저장매체보다 접근하는 시간이 짧고,  프로세스가 공유가 가능한 상태에서 사용한다는 장점이 있다.

- 프로세스는 다른 프로세스의 공간을 접근할 수 없다. 프로세스들이 서로의 공간을 쉽게 접근할 수 있다면 위험하기 때문이다.



### 프로세스간 통신이 필요한가?

- 여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위해 프로세스간 통신이 필요하다.
  - 프로세스를 fork()해서, 여러 프로세스를 동시에 실행시킬 수 있음 (8초 걸릴일을 1초에 해결할 수 있음)
  - 웹서버 만들기 (서버란? 요청이 오면, HTML 파일을 클라이언트에 제공하는 프로그램, 새로운 사용자 요청이 올 때마다, fork() 함수로 새로운 프로세스를 만들고, 각 사용자 요청에 즉시 대응)
- 이때 프로세스간 상태 확인 및 데이터 송수신이 필요



> fork() 시스템콜
>
> - fork() 함수로 프로세스 자신을 복사해서 새로운 프로세스로 만들 수 있음
> - 부모 프로세스(원래 프로세스), 자식 프로세스()



### 실제 프로세스: 리눅스 예

- 프로세스 공간은 완전히 분리되어 있다. (하나의 프로세스는 4GB, 단, 가상 주소임)
- 3GB ~ 4GB는 Kernel Space, 0 ~ 3GB는 User Space
- 커널 공간은 공유한다.



### 각 IPC 기법 알아보기

모두 kernel 공간의 메모리를 사용한다. 메모리 공간도 kernel/user로 구분된다.

signal, socket은 IPC 기법이지만, 이외에도 많이 사용된다.

- pipe
  - 기본 파이프는 **단방향** 통신
  - fork()로 자식 프로세스를 만들었을 때만 부모와 자식간의 통신이 가능
    - 부모 프로세스의 fd[1] write -> 자식 프로세스 fd[0] read
- message queue
  - queue, 기본은 FIFO 정책으로 데이터 전송 (먼저 넣은 데이터가 먼저 읽혀짐)
  - 어느 프로세스간에도 데이터 송수신이 가능 (**양방향**)
- 공유 메모리 (shared memory)
  - 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
  - 해당 메모리 주소를 마치 변수처럼 접근하는 방식
  - 공유 메모리 key를 가지고 여러 프로세스가 접근 가능
- 시그널 (signal)
  - 유닉스에서 30년 이상 사용된 전통적인 기법
  - 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
  - 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
    - 시그널 무시
    - 시그널 블록 (블록을 푸는 순간, 프로세스에 해당 시그널 전달)
    - 등록된 시그널 핸들러로 특정 동작 수행
    - 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행
  - PCB에 해당 프로세스 블록 또는 처리해야하는 시그널 관련 정보 관리 , 커널모드에서 사용자모드로 전환시 시그널을 처리한다.

- 소켓 (socket)
  - 소켓은 네트워크 통신을 위한 기술
  - 기본적으로는 클라이언트와 서버 등 두 개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술
  - 소켓을 하나의 컴퓨터 안에서 두개의 프로세스간에 통신 기법으로 사용가능





