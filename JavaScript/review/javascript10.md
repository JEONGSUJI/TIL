# **원시 값과 객체의 비교**

**데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유**
1) 원시 타입의 값은 변경 불가능한 값이지만 객체(참조)타입의 값은 변경 가능한 값이다.
2) **원시 값**을 변수에 할당하면 변수에는 **실제 값이 저장**된다. 이에 비해 **객체**를 변수에 할당하면 **참조 값이 저장**된다.
3) 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달(값에 의한 전달)된다. 반면, 객체를 가리키는 변수는 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(참조에 의한 전달)된다.



## 1. 원시값
- 변경 불가능한 값 
  - 원시 값은 변경 불가능한 값이다. 변경 불가능하다는 것은 변수가 아닌 값에 대한 진술을 말한다.
  - 단, 변수는 새로운 값을 재할당하는 것으로 변수값을 변경할 수 있다. 재할당이 금지된 변수는 별도로 상수라고 부른다.
  - 상수는 재할당이 금지되지만 상수에 할당된 객체는 변경할 수 있다.
  - 불변성: 변수의 값을 변경하기 위해 원시값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다.

  
  
- 문자열과 불변성
  - 원시값인 문자열은 0개 이상인 문자들의 집합을 말하며 1개의 문자는 2byte의 메모리 공간에 저장된다. 따라서 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 결정된다.
  
  

  > 이와같은 이유로 C는 하나의 문자를 위한 데이터 타입만 존재할 뿐 타입이란 존재하지 않는다. C는 문자열을 문자들의 배열로 처리하고 Java는 문자열을 String 객체로 처리한다.
  
  
  
  - 문자열은 **유사 배열 객체**(마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체)이므로 배열과 유사하게 각 문자에 접근할 수 있다. 
  
  
  
- 값에 의한 전달
  - 변수에 변수를 할당하는 경우 할당되는 변수가 원시값을 갖는 변수라면 할당받는 변수에는 할당받는 변수의 원시값이 복사되어 전달
  - 다른 메모리 공간의 저장된 별개의 값으로 하나를 변경하여도 다른 하나에 어떠한 영향도 주지 않는다.
  
  
  
  ![](https://poiemaweb.com/assets/fs-images/10-4.png)
  
  

## 2. 객체
- 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 따라서 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.



- 변경 가능한 값
  - 객체를 할당한 변수는 참조 값을 값으로 갖는다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다. 
  - 객체를 할당한 변수를 평가하면 메모리에 저장되어 있는 참조 값을 반환하는 것이 아닌 참조 값을 통해 실제 객체에 접근해 그 객체를 반환한다.  (객체를 할당한 변수의 경우 "변수는 객체를 참조하고 있다", "변수는 객체를 가리키고 있다"라고 표현한다.)
  - 원시값을 갖는 변수의 값을 변경하려면 재할당 이외에는 방법이 없었으나, 객체는 생성된 이후에도 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.



- 참조에 의한 전달
  
  - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.
  - 부작용: 여러 개의 식별자가 하나의 객체를 공유할 수 있어 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
  
  

![](https://poiemaweb.com/assets/fs-images/10-8.png)