# this

## 0. 결론

**this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.**

- 전역에서 this는 전역 객체 window를 가리킨다.
- 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.
- 메소드 내부에서 this는 메소드를 호출한 객체를 가리킨다.
- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.



## 1. this 키워드

- **객체 리터럴 방식으로 생성한 객체의 경우, 메소드 내부에서 메소드 자신이 속한 객체를 가리키는 식별자를 재귀적으로 참조할 수 있다.** 객체 리터럴은 할당 단계에 평가되어 메소드가 호출되는 시점에 이미 객체 리터럴의 평가가 완료되어 객체가 생성되었고 식별자 circle에 생성된 객체가 할당된 이후이기 때문이다.



- **생성자 함수로 인스턴스를 생성한 객체의 경우,  내부에서 프로퍼티 또는 메소드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다. **생성자 함수 방식으로 생성한 객체의 경우, 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 먼저 생성자 함수를 정의한 이후 new 연산자와 함께 생성자 함수를 호출하는 단계가 추가로 필요하다.



- **this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다.**
- 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다.

- 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다.



> 바인딩 : 식별자와 값을 연결하는 과정을 의미한다.



+. this 코드는 어디든지 참조가능하다.

+. 엄격 모드 역시 this 바인딩에 영향을 준다.  strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다.



## 2. 함수 호출 방식과 this 바인딩



> **렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.**
>
> 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. this에 바인딩될 객체는 함수 호출 시점에 결정된다.
>
> 렉시컬 스코프는 정적, this 바인딩은 동적



함수를 호출하는 방식은 총 4가지가 있다. (*단, 주의할 점은 동일한 함수도 다양한 방식으로 호출할 수 있다는 것이다.*)

1) 일반 함수 호출 <code>foo();</code>

2) 메소드 호출 <code>O.foo();</code>

3) 생성자 함수 호출 <code>new foo();</code>

4) Function.prototype.apply/call/bind 메소드에 의한 간접호출 <code>foo.call(bar);</code>



### 1) 일반 함수 호출 

- this에 전역 객체가 바인딩된다.
- **콜백 함수 내부의 this에도 전역 객체가 바인딩된다.** 어떠한 함수라도 일반 함수로 호출되면 this 전역 객체가 바인딩되기 때문이다.
- 일반함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.



### 2) 메소드 호출

- 메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표 연산자 앞에 기술한 객체에 바인딩된다.
- 주의할 점은 메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다는 것이다.



### 3) 생성자 함수 호출

- 생성자 함수 내부의 this에는 생성자 함수가 미래에 생성할 인스턴스가 바인딩된다.



### 4) Function.prototype.apply/call/bind 메소드에 의한 간접 호출

- Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply, call, bind 메소드는 Function.prototype의 메소드이다.

```javascript
// 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.
// thisArg => this로 사용될 객체
// argsArray=> 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체

Function.prototype.apply(thisArg[, argsArrays])
Function.prototype.call(thisArg[, arg1[, arg2[, ... ]]])
```

- apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다.
- **apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.**
- apply와 call 메소드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다.
  - apply 메소드는 호출할 함수의 인수를 배열로 묶어 전달한다.
  - call 메소드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.

- **apply와 call 메소드의 대표적인 용도**는 **arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다**.



- Function.prototype.bind 메소드는 apply와 call 메소드와는 달리 함수를 호출하지 않고 this로 사용할 객체만을 전달한다. 
  -  bind 메소드는 함수를 호출하지는 않는다. 
  -  bind 메소드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다. 

- **bind 메소드는 메소드의 this와 메소드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.  **