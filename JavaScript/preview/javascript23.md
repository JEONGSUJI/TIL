# 클로저(closure)

클로저는 자바스크립트의 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

> **MDN 상에서의 클로저의 정의**
>
> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.



## 1. 렉시컬 스코프(정적 스코프)

- 렉시컬 스코프는 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정하는 것을 말한다.

- 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신이 외부 렉시컬 환경에 대한 참조(Outer Lexical Enviroment Reference)를 통해 상위 렉시컬 환경과 연결된다. 이것이 바로 스코프 체인이다.
- 함수의 상위 스코프를 결정한다 = 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다
- **렉시컬 스코프란 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다.**



## 2. 함수 객체의 내부 슬롯 [[Environment]]

- 함수는 자신의 내부 슬롯[[Enviroment]]에 자신이 정의된 환경, 즉 렉시컬 스코프의 참조를 저장한다.
-  **함수 객체의 내부 슬롯 [[Environment]]에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다** 
- 함수 정의가 평가되어 객체를 생성할 때, 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯에 저장한다
  - **전역에서 정의된 함수 선언문**: 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성 > **생성된 함수 객체의 내부슬롯에는** 함수 정의가 평가된 시점 = 전역 코드 평가 시점에 실행중인 실행 컨텍스트의 렉시컬 환경인 **전역 렉시컬 환경의 참조가 저장**
  - **함수 내부에서 정의된 함수 선언문** : 외부 함수 코드가 평가되는 시점에 평가되어 함수 객체를 생성 > **생성된 함수 객체의 내부슬롯에는** 외부 함수 코드 평가 시점에 실행중인 실행 컨텍스트의 렉시컬 환경인 **외부 렉시컬 환경의 참조가 저장**

![](https://poiemaweb.com/assets/fs-images/23-1.png)



## 3. 클로저와 렉시컬 환경

- **클로저(closure)는 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는 함수를 말한다.**

- 외부함수의 실행이 종료되면 외부함수의 생명주기는 종료한다. **단, 외부함수의 실행 컨텍스트는 실행 컨텍스트에서 제거되지만 외부 함수의 렉시컬 환경까지 소멸하는 것은 아니다.** 외부 함수의 렉시컬 환경은 중첩함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있으므로 가비지 컬렉션의 대상이되지 않는다.
- 중첩 함수는 외부 함수의 생존 여부와 상관없이 자신이 정의된 위치에 의해 결정된 상위 스코프를 기억한다. 중첩함수 내부에서 상위 스코프를 참조할 수 있으므로 상위 스코프 식별자를 참조할 수 있고 식별자의 값을 변경할 수도 있다.

- 클로저가 아닌 경우
  - 중첩 함수 중 상위 스코프의 식별자를 참조하고 있지 않고 외부 함수와 더불어 소멸되기 때문에  상위 스코프를 기억한다는 클로저의 역할에 부합하지 않는다. 
- 클로저에 의해 참조되는 상위 스코프의 변수를 **자유 변수**라고 부른다.
- 단 , 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다.



## 4. 클로저의 활용

- 클로저는 상태를 안전하게 유지하기 위해 사용된다. (상태가 의도치 않게 변경되지 않도록 **은닉**한다. 그리고 이전 상태를 기억하다 상태 변경 시 **최신 상태를 유지**한다.

```javascript
<!DOCTYPE html>
<html>
<body>
  <button class="increase">+</button>
  <span class="counter">0</span>

  <script>
    const $counter = document.querySelector('.counter');
    
    const increase = (function () {
      let num = 0;
      return function(){
        $counter.textContent = ++num; // 상태 변화
      }
    }());

    document.querySelector('.increase').onclick = increase;
  </script>
</body>
</html>
```

- 위 예제에서 increase는 클로저이다. 변수 increase에 할당된 return으로 적힌 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저이다.

- 따라서 즉시 실행 함수가 반환한 클로저 increase는 카운트 상태를 유지하기 위한 자유 변수 num을 언제 어디서나 호출, 참조, 변경이 가능하다.

```javascript
<!DOCTYPE html>
<html>
<body>
  <button class="increase">+</button>
  <span class="counter">0</span>
  <button class="decrease">-</button>

  <script>
    const $counter = document.querySelector('.counter');

    const Counter = (function () {
      // ① 카운트 상태를 유지하기 위한 자유 변수
      let num = 0;

      function Counter() {
        // this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.
      }

      Counter.prototype.increase = function () {
        $counter.textContent = ++num;
      };

      Counter.prototype.decrease = function () {
        if (num <= 0) return;
        $counter.textContent = --num;
      };

      return Counter;
    }());

    const counter = new Counter();

    document.querySelector('.increase').onclick = counter.increase;
    document.querySelector('.decrease').onclick = counter.decrease;
  </script>
</body>
</html>
```

- 위 예제는 decrease까지 추가해 생성자 함수를 만들 때 생성자 함수를 활용한 방법이다.
- 위와 같은 방법을 통해 선언된 변수 num은 인스턴스를 통해 접근할 수 없으며, 즉시 실행 함수 외부에서도 접근할 수 없는 은닉된 변수다. 
- 생성자 함수는 프로토타입을 통해 상속받는 인스턴스가 생성되는데 이 메소드들은 모두 자신의 함수 정의가 평가되어 함수 객체가 될 때, 즉시 실행 함수실행 컨텍스트의 렉시컬 환경을 기억하는 클로저이다. 따라서 프로토타입을 통해 상속되는 프로토타입 메소드일지라도 즉시 실행 함수의 자유변수 num을 참조할 수 있다. 즉 num은 increase, decrease 메소드만이 변경할 수 있다. 이러한 클로저의 특징을 사용해 클래스 기반 언어의 private 키워드를 흉내낼 수 있다.
- 변수는 누군가에 의해 언제든 변경될 수 있어 상태 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극 사용됨



## 5. 자주 발생하는 실수

- 클로저에서 var를 사용하게 되면 함수 레벨 스코프를 갖는 var의 특성 상 전역 변수가 되어 원하는 결과값이 나오지 않을 수 있다.
- 위와 같은 문제를 해결하기 위해
  - ES6의 let 키워드를 사용해 블록 레벨 스코프를 갖는 let의 특성 상 for 문 내 정의된 함수가 있다면 for문이 반복될 때마다 생성된 for문 코드블록의 새로운 렉시컬 환경이 된다.
  - 고차 함수를 사용한다. 이 방법은 변수와 반복문의 사용을 억제할 수 있기 때문에 오류를 줄이고 가독성을 좋게 만든다.